### 渲染管线

- 定义: 显卡内部处理图像信号的并行处理单元,也称为渲染流水线
- 发生位置: CPU和GPU
- 渲染机理: 将图像所具备的图形信息(顶点、纹理、材质、摄像机位置等)经过一系列阶段的处理,最终- 转换为屏幕上的图像.
- 渲染流程:
    - 应用阶段
    - 几何阶段
    - 光栅化阶段
    
![769eae9688803605f83baa9c3f2da1f9.png](img/4880_1.png)

- **应用阶段 Application Stage**
- 发生位置: CPU
- 阶段目标: 准备渲染所需的几何信息,即渲染图元(rendering primitives)
- 渲染数据:
    - 场景数据:如摄像机,视锥体,模型,光源..
    - 粗粒度剔除:即剔除不可见物体
    - 渲染状态:材质,纹理,Shader..
- 基本流程：
    - 加载数据到显存: 由于渲染管线的图形化处理基本位于GPU,所以渲染数据先从硬盘加载到RAM,再加载到显存以供GPU后续处理.
    - 设置渲染状态: 定义渲染图形的方式,例如使用顶点着色器或者片元着色器、材质、光源等.
    - 调用Draw Call: 由CPU发起的DrawCall指令给GPU,指向已经准备好的渲染图元
- Draw Call:
    - 本质:图像编程接口
    - 机理:CPU通过调用DrawCall向命令缓冲区(Command Buffer)的队列中添加渲染命令,而GPU则从已有的队列中读取渲染命令去执行
    - 优化:由于调用DrawCall即使得CPU准备大量渲染数据提交到缓冲队列,大量的DrawCall会使得CPU过载,因此尽量减少DrawCall的调用次数(如进行批处理,合并网格...)
- **几何阶段 Geometry Stage**
    - 发生位置: GPU
    - 接收数据: 应用阶段所准备好的渲染图元的信息，也就是顶点数据（模型自身坐标系、顶点颜色、纹理UV等）
    - 阶段目标: 决定所需绘制图元的信息(绘制方法,绘制坐标)
    - 基本流程:
        - 顶点着色器(Vertex Shader): 
            - 调用次数:每个顶点均调用一次
            - 工作:坐标转换(模型空间->齐次裁剪空间，也可说模型自身坐标->屏幕空间坐标。可人为干涉)和逐顶点光照(颜色计算)
        - 曲面细分着色器(Tessellation Shader):
            - 工作:细分图元
        - 几何着色器(Geometry Shader):
            - 工作:逐图元着色操作或是生成新的图元(减少CPU负担)
        - 裁剪(Clipping):
            - 工作:裁剪去不在摄像机视野内的顶点
        - 屏幕映射(Screen Mapping):
            - 工作:将图元的x和y坐标转换到屏幕坐标系(不对z坐标处理)
- **光栅化阶段 Rasterizer Stage**
    - 发生位置: GPU
    - 接收数据: 几何阶段准备好的顶点信息
    - 阶段目标: 对几何阶段传递过来的屏幕空间的顶点信息进行处理,最终生成屏幕像素,渲染出图像
    - 基本流程:
        - 三角形设置(Triangle Setup):
            - 工作:根据几何阶段传递的数据(三角网络的顶点),计算三角网络每边的数据信息
        - 三角形遍历(Triangle Traversal):
            - 工作:根据三角形设置的结果,判断某个三角网格所覆盖的像素,并根据三个顶点的信息对整个覆盖区域进行 插值 ,生成一系列 片元(fragment) ，片元包含信息有:屏幕坐标、深度、法线、纹理...
        - 片元着色器(Fragment Shader): 又称像素着色器(Pixel Shader)
            - 调用次数:一个像素点调用一次
            - 工作:纹理采样,计算光照(阴影、明暗...)
        - 逐片元操作(Per-Fragment Operations):
            - 工作:模板测试->深度测试->混合->颜色缓冲区
        - 输出屏幕图像


### Unity DrawCall详解
https://blog.csdn.net/yu1368072332/article/details/85676537

### OpenGL渲染管线

绝大数OpenGL实现都有相似的操作顺序，一系列相关的处理阶段称为OpenGL渲染管线。图1-2显示了这些顺序，虽然并没有严格规定OpenGL必须采用这样的实现，但它提供了一个可靠的指南，可以预测OpenGL将以什么样的顺序来执行这些操作。
如果读者刚开始涉足三维图形编程，可能会对接下来的内容感到吃力。读者现在可以跳过这一部分内容，但在读完这本书的每一章时，都应该重温一下图1-2

![311269b2263ba839611cb9d09a201d13.png](img/4882_1.png)

![56ac48eac59de632671b924eef2bd350.jpeg](img/4884_1.jpg)

图1-2显示了Henry Ford在福特汽车公司采用的装配线方法，它也是OpenGL处理数据的方法。几何数据(顶点，直线和多边形)所经历的处理阶段包括求值和基于顶点的操作，而像素数据(像素，图像和位图)的处理过程侧有所不同。在最终的像素数据写入到帧缓冲区之前，这两种类型的数据都将经过相同的最终步骤(光棚化和基于片断的操作)。下面，我们更为详细地介绍OpenGL渲染管线的一些关键阶段。

1. 显示列表Display Lists
任何数据，不管它所描述的是几何图形还是像素，都可以保存在显示列表(display list)中，供当前或以后使用。当然，我们也可以不把数据保存在显示列表中，而是立即对数据进行处理，这种模式也称为立即模式(immediate mode)。当一个显示列表被执行时，被保存的数据就从显示列表中取出，就像在立即模式下直接由应用程序所发送的那样。
2. 求值器Evaluators
所有的几何图元最终都要通过顶点来描述。参数化曲线和表面最初可能是通过控制点以及成为基函数(Basic function)的多项式函数进行描述的。求职器提供了一种方法。根据控制点计算表示表面的顶点。这种方法是一种多项式映射，它可以根据控制点产生表面法线、纹理坐标、颜色以及空间坐标。
3. 基于顶点的操作Per-Vertex Operations
对于顶点数据，接下来的一个步骤就是"基于顶点的操作"，就是把顶点变换为图元。有些类型的顶点数据(例如空间坐标)是通过一个4x4 的浮点矩阵进行变换的。空间坐标从3D世界的一个位置投影到屏幕上的一个位置。如果启用了高级特性，这个阶段将更为忙碌。如果使用了纹理，这个阶段还将生成并变换纹理坐标。如果启用了光照，就需要综合变换后的顶点，表面法线，光源位置，材料属性以及其他光照信息进行光照计算，产生最终的颜色值。
4. 图元装配Primitive Assembly
图元装配的一个主要内容就是剪裁，它的任务是消除位于半空间(half-space)之外的那部分几何图元，而这个半空间是由一个平面所定义的。点剪裁就是简单地接受或拒绝顶点，直线或多边形剪裁则可能需要添加额外的顶点，具体取决于直线或多边形是如何进行剪裁的。在有些情况下，接下来需要执行一个称为透视除法(perspective division)的步骤。它使远处的物体看起来比近处的物体更小一些。接下来所进行的是视口(viewport)和深度(z 坐标)操作。如果启用了剔除功能(culling)并且该图元是个多边形，那么它就有可能被剔除测试所拒绝。取决于多边形模式，多边形可能被画成点的形式或者直线的形式。这个阶段所产生的结果就是完整的几何图元，也就是根据相关的颜色，深度(有时还有纹理坐标值以及和光棚化处理有关的一些指导信息)进行了变换和剪裁的顶点。
5. 像素操作Pixel Operations
在 OpenGL 的渲染管线中，和单路径的几何数据相比，像素数据所经历的流程有所不同。首先，来自系统内存的一个数组中的像素进行解包，从某种格式(像素的原始格式可能有多种)解包为适当数量的数据成分。接着，这些数据被缩放、偏移，并根据一副像素图进行处理。处理结果先进行截取，然后或者写入到纹理内存，或者发送到光棚化阶段。如果像素数据时从帧缓冲区读取的，就对他们执行像素转换操作(缩放、偏移、映射和截取)。然后，这些结果被包装为一种适当的格式，并返回到系统内存的一个数组中。OpenGL 有一种特殊的像素复制操作，可以把数据从帧缓冲区复制到帧缓冲区的其他位置或纹理内存中。这样，在数据写入到纹理内存或者写回到帧缓冲区之前，只需要进行一道像素转换就可以了。
6. 纹理装配Texture Assembly
OpenGL 应用程序可以在几何物体上应用纹理图像，使它们看上去更为逼真。如果需要使用多幅纹理图像，把它们放在纹理对象中是一种明智的做法。这样，就可以很方便地在他们之间进行切换。有些 OpenGL 实现拥有一些特殊的资源，可以加速纹理的处理。这种资源可能是专用的，高性能的纹理内存。如果确实拥有这种内存，纹理对象可能会优先进行处理，以控制这种有限和宝贵的资源的使用。
7. 光棚化Rasterization
光棚化就是把几何数据和像素数据转换为片断(fragment)的过程。每个片断方块对应用于帧缓冲区中的一个像素。把顶点连接起来形成直线或者计算填充多边形的内部像素时，需要考虑直线和多边形的点画模式，直线的宽度，点的大小，着色模型以及用于支持抗锯齿处理的覆盖计算。每个片断方块都将具有各自的颜色和深度值。
8. 片断操作Fragment Operations
在数据实际存储到帧缓冲区之前， 将要执行一系列的操作。这些操作可能会修改甚至丢弃这些片断。所有这些操作都可以被启用或禁用。第一个可能执行的操作时纹理处理。在纹理内存中为每个片断生成一个纹理单元(texel，也就是纹理元素)，并应用到这个片断上。接着可能进行的是雾计算，然后是剪裁测试，alpha测试，模板测试和深度缓冲区测试(深度缓冲区用于消除被隐藏的表面)。如果一个片断无法通过一个启用的测试，它的连续处理过程可能会被中断。随后，将要执行的可能是混合，抖动，逻辑操作以及根据一个位掩码的屏蔽操作。最后，经过完整处理的片断就被绘制到适当的缓冲区，最终成为一个像素并到达它的最终栖息地。


### 光照模型
这里图片和知识点太多，就直接贴源地址了
1. [Unity Shader-学习-3.光照模型](https://www.jianshu.com/p/53c6710db1c5)
2. [Unity Shader-标准光照模型总结](https://blog.csdn.net/u010832643/article/details/90580897)
3. [Unity Shader-兰伯特光照模型与Diffuse Shader](https://blog.csdn.net/puppet_master/article/details/53074789)
4. [Unity Shader-Phong光照模型与Specularr](https://blog.csdn.net/puppet_master/article/details/53428885)

### 延迟渲染
我们知道，正向渲染(Forward Rendering)，或称正向着色(Forward Shading)，是渲染物体的一种
非常直接的方式，在场景中我们根据所有光源照亮一个物体，之后再渲染下一个物体，以此
类推。
传统的正向渲染思路是，先进行着色，再进行深度测试。 其的主要缺点就是光照计算跟场景
复杂度和光源个数有很大关系。假设有 n 个物体， m 个光源，且每个每个物体受所有光源的
影响，那么复杂度就是 O(m*n)。

正向渲染简单直接，也很容易实现，但是同时它对程序性能的影响也很大，因为对每一个需
要渲染的物体，程序都要对每个光源下每一个需要渲染的片段进行迭代，如果旧的片段完全
被一些新的片段覆盖，最终无需显示出来，那么其着色计算花费的时间就完全浪费掉了。

可以将延迟渲染( Deferred Rendering)理解为先将所有物体都先绘制到屏幕空间的缓冲（即 Gbuffer， Geometric Buffer，几何缓冲区）中，再逐光源对该缓冲进行着色的过程，从而避免了
因计算被深度测试丢弃的⽚元的着色而产⽣的不必要的开销。 也就是说 延迟渲染基本思想
是，先执行深度测试，再进行着色计算，将本来在物空 间（三维空间）进行光照计算放到了
像空间（二维空间）进行处理。
对应于正向渲染 O(m*n)的 复杂度，经典的延迟渲染复杂度为 O(n+m)。


### shader 动态模糊
https://zhuanlan.zhihu.com/p/99487181